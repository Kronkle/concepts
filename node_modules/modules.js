// exports vs. module.exports

/*  
 *  Initially, exports and module.exports point to the same empty object representing exported modules -> {}
 *  	
 *		exports is a module-global variable that is made for convenience
 *
 *  	module.exports is a property of the local module variable
 *				-the object that module.exports points to will be returned when a module is require'd
 *
 *	module.exports and exports always point to the same object unless their object reference is overwritten
 */

module.exports = function () {
	console.log("module.exports points to a constructor function now, and no longer the same object that exports points to");
}

exports = function () {
	console.log("exports points to a constructor function now, and no longer the same object that module.exports points to");
}

/* 
 *	However, module.exports and exports will still point to the same object if only properties of the object are manipulated
 * 		-This won't overwrite an object reference
 *
 *	This behavior demonstrates how JavaScript passes a copy of a reference to an object (or reference value) to functions
 */

module.exports.a = function () {
	console.log("This attaches function a to the same object that module.exports and exports point to");
}

exports.b = function () {
	console.log("This attaches function b to the same object that exports and module.exports point to");
}

// An example of pass-by-reference-value:

// Imagine that puppy points to address 001, which contains {name: "Avett"}
var puppy = {name: "Avett"};

function changePuppyProp(ref) {
	// COPY of pointer value to 001 is changed to point to new object at 002. Original pointer isn't changed
	ref = {coat: "Merle"};
}

function addPuppyProp(ref) {
	// Additional pointer to value "Merle" is appended as a property to COPY of pointer value to 001. Original pointer is changed
	ref.coat = "Merle";
}

// name still exists and coat doesn't
changePuppyProp(puppy); 
console.log(puppy);

// name still exists and so does coat
addPuppyProp(puppy);
console.log(puppy);
